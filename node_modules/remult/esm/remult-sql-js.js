import { SqlDatabase } from './src/data-providers/sql-database.js';
import { dbNamesOf, isDbReadonly, } from './src/filter/filter-consumer-bridge-to-sql-request.js';
import { isAutoIncrement } from './src/remult3/RepositoryImplementation.js';
export class SqlJsDataProvider {
    db;
    constructor(db) {
        this.db = db;
    }
    getLimitSqlSyntax(limit, offset) {
        return ' limit ' + limit + ' offset ' + offset;
    }
    afterMutation;
    createCommand() {
        return new SqlJsCommand(this.db);
    }
    transaction(action) {
        throw new Error('Method not implemented.');
    }
    async entityIsUsedForTheFirstTime(entity) {
        await this.createTable(entity);
    }
    async ensureSchema(entities) {
        for (const entity of entities) {
            await this.createTable(entity);
        }
    }
    async dropTable(entity) {
        let e = await dbNamesOf(entity);
        let sql = 'drop  table if exists ' + e.$entityName;
        if (SqlDatabase.LogToConsole)
            console.info(sql);
        await this.createCommand().execute(sql);
    }
    addColumnSqlSyntax(x, dbName) {
        let result = dbName;
        const nullNumber = x.allowNull ? '' : ' default 0 not null';
        if (x.valueType == Date)
            result += ' integer';
        else if (x.valueType == Boolean)
            result += ' integer ' + nullNumber;
        else if (x.valueType == Number) {
            if (!x.valueConverter.fieldTypeInDb)
                result += ' real ' + nullNumber;
            else
                result += ' ' + x.valueConverter.fieldTypeInDb + ' ' + nullNumber;
        }
        else
            result += ' text' + (x.allowNull ? ' ' : " default '' not null ");
        return result;
    }
    async createTable(entity) {
        let result = '';
        let e = await dbNamesOf(entity);
        for (const x of entity.fields) {
            if (!isDbReadonly(x, e) || isAutoIncrement(x)) {
                if (result.length != 0)
                    result += ',';
                result += '\r\n  ';
                if (isAutoIncrement(x)) {
                    if (x.key != entity.idMetadata.field.key)
                        throw 'in web sql, autoincrement is only allowed for primary key';
                    result += e.$dbNameOf(x) + ' integer primary key autoincrement';
                }
                else {
                    result += this.addColumnSqlSyntax(x, e.$dbNameOf(x));
                    if (x.key == entity.idMetadata.field.key) {
                        result += ' primary key';
                    }
                }
            }
        }
        let sql = 'create table if not exists ' + e.$entityName + ' (' + result + '\r\n)';
        if (SqlDatabase.LogToConsole)
            console.log(sql);
        await this.createCommand().execute(sql);
    }
    supportsJsonColumnType;
    wrapIdentifier(name) {
        return name;
    }
}
class SqlJsCommand {
    db;
    values = {};
    i = 0;
    constructor(db) {
        this.db = db;
    }
    async execute(sql) {
        if (this.i == 0)
            return new SqlJsSqlResult((await this.db).exec(sql));
        return new SqlJsSqlResult((await this.db).exec(sql, this.values));
    }
    addParameterAndReturnSqlToken(val) {
        if (val instanceof Date)
            val = val.valueOf();
        const key = ':' + ++this.i;
        this.values[key] = val;
        return key;
    }
}
class SqlJsSqlResult {
    result;
    constructor(result) {
        this.result = result;
        this.rows =
            result[0]?.values.map((row) => row.reduce((prev, curr, i) => ({ ...prev, [result[0].columns[i]]: curr }), {})) ?? [];
    }
    rows;
    getColumnKeyInResultForIndexInSelect(index) {
        return this.result[0]?.columns[index];
    }
}
