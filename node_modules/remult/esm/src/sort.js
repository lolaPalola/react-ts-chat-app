import { CompoundIdField } from './CompoundIdField.js';
import { getRelationFieldInfo } from './remult3/relationInfoMember.js';
export class Sort {
    toEntityOrderBy() {
        let result = {};
        for (const seg of this.Segments) {
            if (seg.isDescending) {
                result[seg.field.key] = 'desc';
            }
            else
                result[seg.field.key] = 'asc';
        }
        return result;
    }
    constructor(...segments) {
        this.Segments = segments;
    }
    Segments;
    reverse() {
        let r = new Sort();
        for (const s of this.Segments) {
            r.Segments.push({ field: s.field, isDescending: !s.isDescending });
        }
        return r;
    }
    compare(a, b, getFieldKey) {
        if (!getFieldKey)
            getFieldKey = (x) => x.key;
        let r = 0;
        for (let i = 0; i < this.Segments.length; i++) {
            let seg = this.Segments[i];
            let left = fixValueForSort(a[getFieldKey(seg.field)]);
            let right = fixValueForSort(b[getFieldKey(seg.field)]);
            if (left > right)
                r = 1;
            else if (left < right)
                r = -1;
            if (r != 0) {
                if (seg.isDescending)
                    r *= -1;
                return r;
            }
        }
        return r;
    }
    static translateOrderByToSort(entityDefs, orderBy) {
        if (!orderBy)
            return undefined;
        let sort = new Sort();
        if (orderBy)
            for (const key in orderBy) {
                if (Object.prototype.hasOwnProperty.call(orderBy, key)) {
                    const element = orderBy[key];
                    let field = entityDefs.fields.find(key);
                    const addSegment = (field) => {
                        switch (element) {
                            case 'desc':
                                sort.Segments.push({ field, isDescending: true });
                                break;
                            case 'asc':
                                sort.Segments.push({ field });
                        }
                    };
                    if (field) {
                        const rel = getRelationFieldInfo(field);
                        if (rel?.type === 'toOne') {
                            const op = rel.options;
                            if (typeof op.field === 'string') {
                                addSegment(entityDefs.fields.find(op.field));
                            }
                            else {
                                if (op.fields) {
                                    for (const key in op.fields) {
                                        if (Object.prototype.hasOwnProperty.call(op.fields, key)) {
                                            const keyInMyEntity = op.fields[key];
                                            addSegment(entityDefs.fields.find(keyInMyEntity.toString()));
                                        }
                                    }
                                }
                            }
                        }
                        else
                            addSegment(field);
                    }
                }
            }
        return sort;
    }
    static createUniqueSort(entityMetadata, orderBy) {
        if ((!orderBy || Object.keys(orderBy).length === 0) &&
            entityMetadata.options.defaultOrderBy)
            orderBy = Sort.translateOrderByToSort(entityMetadata, entityMetadata.options.defaultOrderBy);
        if (!orderBy)
            orderBy = new Sort({ field: entityMetadata.idMetadata.field });
        if (entityMetadata.idMetadata.field instanceof CompoundIdField) {
            for (const field of entityMetadata.idMetadata.field.fields) {
                if (!orderBy.Segments.find((x) => x.field == field)) {
                    orderBy.Segments.push({ field: field });
                }
            }
        }
        else if (!orderBy.Segments.find((x) => x.field == entityMetadata.idMetadata.field)) {
            orderBy.Segments.push({ field: entityMetadata.idMetadata.field });
        }
        return orderBy;
    }
    static createUniqueEntityOrderBy(entityMetadata, orderBy) {
        if (!orderBy || Object.keys(orderBy).length === 0)
            orderBy = entityMetadata.options.defaultOrderBy;
        if (!orderBy)
            orderBy = {
                [entityMetadata.idMetadata.field.key]: 'asc',
            };
        else
            orderBy = { ...orderBy };
        if (entityMetadata.idMetadata.field instanceof CompoundIdField) {
            for (const field of entityMetadata.idMetadata.field.fields) {
                if (!orderBy[field.key]) {
                    orderBy[field.key] = 'asc';
                }
            }
        }
        else if (!orderBy[entityMetadata.idMetadata.field.key]) {
            orderBy[entityMetadata.idMetadata.field.key] = 'asc';
        }
        return orderBy;
    }
}
function fixValueForSort(a) {
    if (a == undefined || a == null)
        return a;
    if (a.id !== undefined)
        return a.id;
    return a;
}
