import { SqlDatabase } from '../data-providers/sql-database.js';
import { getEntityMetadata } from '../remult3/RepositoryImplementation.js';
import { getRelationFieldInfo } from '../remult3/relationInfoMember.js';
export class FilterConsumerBridgeToSqlRequest {
    r;
    nameProvider;
    where = '';
    _addWhere = true;
    promises = [];
    async resolveWhere() {
        while (this.promises.length > 0) {
            let p = this.promises;
            this.promises = [];
            for (const pr of p) {
                await pr;
            }
        }
        return this.where;
    }
    constructor(r, nameProvider) {
        this.r = r;
        this.nameProvider = nameProvider;
    }
    custom(key, customItem) {
        throw new Error('Custom filter should be translated before it gets here');
    }
    or(orElements) {
        let statement = '';
        this.promises.push((async () => {
            for (const element of orElements) {
                let f = new FilterConsumerBridgeToSqlRequest(this.r, this.nameProvider);
                f._addWhere = false;
                element.__applyToConsumer(f);
                let where = await f.resolveWhere();
                if (!where)
                    return; //since if any member of or is empty, then the entire or is irrelevant
                if (where.length > 0) {
                    if (statement.length > 0) {
                        statement += ' or ';
                    }
                    if (orElements.length > 1) {
                        statement += '(' + where + ')';
                    }
                    else
                        statement += where;
                }
            }
            this.addToWhere('(' + statement + ')');
        })());
    }
    isNull(col) {
        this.promises.push((async () => this.addToWhere(this.nameProvider.$dbNameOf(col) + ' is null'))());
    }
    isNotNull(col) {
        this.promises.push((async () => this.addToWhere(this.nameProvider.$dbNameOf(col) + ' is not null'))());
    }
    isIn(col, val) {
        this.promises.push((async () => {
            if (val && val.length > 0)
                this.addToWhere(this.nameProvider.$dbNameOf(col) +
                    ' in (' +
                    val
                        .map((x) => this.r.addParameterAndReturnSqlToken(col.valueConverter.toDb(x)))
                        .join(',') +
                    ')');
            else
                this.addToWhere('1 = 0 /*isIn with no values*/');
        })());
    }
    isEqualTo(col, val) {
        this.add(col, val, '=');
    }
    isDifferentFrom(col, val) {
        this.add(col, val, '<>');
    }
    isGreaterOrEqualTo(col, val) {
        this.add(col, val, '>=');
    }
    isGreaterThan(col, val) {
        this.add(col, val, '>');
    }
    isLessOrEqualTo(col, val) {
        this.add(col, val, '<=');
    }
    isLessThan(col, val) {
        this.add(col, val, '<');
    }
    containsCaseInsensitive(col, val) {
        this.promises.push((async () => {
            this.addToWhere('lower (' +
                this.nameProvider.$dbNameOf(col) +
                ") like lower ('%" +
                val.replace(/'/g, "''") +
                "%')");
        })());
    }
    notContainsCaseInsensitive(col, val) {
        this.promises.push((async () => {
            this.addToWhere('not lower (' +
                this.nameProvider.$dbNameOf(col) +
                ") like lower ('%" +
                val.replace(/'/g, "''") +
                "%')");
        })());
    }
    add(col, val, operator) {
        this.promises.push((async () => {
            let x = this.nameProvider.$dbNameOf(col) +
                ' ' +
                operator +
                ' ' +
                this.r.addParameterAndReturnSqlToken(col.valueConverter.toDb(val));
            this.addToWhere(x);
        })());
    }
    addToWhere(x) {
        if (this.where.length == 0) {
            if (this._addWhere)
                this.where += ' where ';
        }
        else
            this.where += ' and ';
        this.where += x;
    }
    databaseCustom(databaseCustom) {
        this.promises.push((async () => {
            if (databaseCustom?.buildSql) {
                let item = new CustomSqlFilterBuilder(this.r);
                await databaseCustom.buildSql(item);
                if (item.sql) {
                    this.addToWhere('(' + item.sql + ')');
                }
            }
        })());
    }
}
export class CustomSqlFilterBuilder {
    r;
    constructor(r) {
        this.r = r;
    }
    sql = '';
    addParameterAndReturnSqlToken(val, field) {
        if (field)
            val = field.valueConverter.toDb(val);
        return this.r.addParameterAndReturnSqlToken(val);
    }
    async filterToRaw(repo, condition) {
        return SqlDatabase.filterToRaw(repo, condition, this);
    }
}
export function isDbReadonly(field, dbNames) {
    return (field.dbReadOnly ||
        field.isServerExpression ||
        (field.options.sqlExpression && field.dbName != dbNames.$dbNameOf(field)));
}
export function shouldNotCreateField(field, dbNames) {
    return (field.isServerExpression ||
        (field.options.sqlExpression && field.dbName != dbNames.$dbNameOf(field)));
}
export async function dbNamesOf(repo, wrapIdentifier = (x) => x) {
    var meta = getEntityMetadata(repo);
    const result = {
        $entityName: await entityDbName(meta, wrapIdentifier),
        toString: () => result.$entityName,
        $dbNameOf: (field) => {
            var key;
            if (typeof field === 'string')
                key = field;
            else
                key = field.key;
            return result[key];
        },
    };
    for (const field of meta.fields) {
        result[field.key] = await fieldDbName(field, meta, wrapIdentifier);
    }
    return result;
}
export async function entityDbName(metadata, wrapIdentifier = (x) => x) {
    if (metadata.options.sqlExpression) {
        if (typeof metadata.options.sqlExpression === 'string')
            return metadata.options.sqlExpression;
        else if (typeof metadata.options.sqlExpression === 'function') {
            return await metadata.options.sqlExpression(metadata);
        }
    }
    return wrapIdentifier(metadata.dbName);
}
export async function fieldDbName(f, meta, wrapIdentifier = (x) => x) {
    try {
        if (f.options.sqlExpression) {
            let result;
            if (typeof f.options.sqlExpression === 'function') {
                result = await f.options.sqlExpression(meta);
            }
            else
                result = f.options.sqlExpression;
            if (!result)
                return f.dbName;
            return result;
        }
        const rel = getRelationFieldInfo(f);
        let field = rel?.type === 'toOne' &&
            f.options.field;
        if (field) {
            let fInfo = meta.fields.find(field);
            if (fInfo)
                return fieldDbName(fInfo, meta, wrapIdentifier);
        }
        return wrapIdentifier(f.dbName);
    }
    finally {
    }
}
