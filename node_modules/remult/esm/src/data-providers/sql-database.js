import { CompoundIdField } from '../CompoundIdField.js';
import { FilterConsumerBridgeToSqlRequest, dbNamesOf, isDbReadonly, } from '../filter/filter-consumer-bridge-to-sql-request.js';
import { Filter, customDatabaseFilterToken, } from '../filter/filter-interfaces.js';
import { remult as defaultRemult } from '../remult-proxy.js';
import { getRepository } from '../remult3/RepositoryImplementation.js';
import { Sort } from '../sort.js';
import { ValueConverters } from '../valueConverters.js';
import { getRepositoryInternals } from '../remult3/repository-internals.js';
// @dynamic
export class SqlDatabase {
    sql;
    static getDb(remult) {
        const r = (remult || defaultRemult).dataProvider;
        if (!r.createCommand)
            throw 'the data provider is not an SqlDatabase';
        return r;
    }
    createCommand() {
        return new LogSQLCommand(this.sql.createCommand(), SqlDatabase.LogToConsole);
    }
    async execute(sql) {
        return await this.createCommand().execute(sql);
    }
    wrapIdentifier = (x) => x;
    /* @internal*/
    _getSourceSql() {
        return this.sql;
    }
    async ensureSchema(entities) {
        if (this.sql.ensureSchema)
            await this.sql.ensureSchema(entities);
    }
    getEntityDataProvider(entity) {
        if (!this.sql.supportsJsonColumnType) {
            for (const f of entity.fields.toArray()) {
                if (f.valueConverter.fieldTypeInDb === 'json') {
                    //@ts-ignore
                    f.valueConverter = {
                        ...f.valueConverter,
                        toDb: ValueConverters.JsonString.toDb,
                        fromDb: ValueConverters.JsonString.fromDb,
                    };
                }
            }
        }
        return new ActualSQLServerDataProvider(entity, this, async (dbName) => {
            if (this.createdEntities.indexOf(dbName.$entityName) < 0) {
                this.createdEntities.push(dbName.$entityName);
                await this.sql.entityIsUsedForTheFirstTime(entity);
            }
        }, this.sql);
    }
    transaction(action) {
        return this.sql.transaction(async (x) => {
            let completed = false;
            try {
                await action(new SqlDatabase({
                    createCommand: () => {
                        let c = x.createCommand();
                        return {
                            addParameterAndReturnSqlToken: (x) => c.addParameterAndReturnSqlToken(x),
                            execute: async (sql) => {
                                if (completed)
                                    throw "can't run a command after the transaction was completed";
                                return c.execute(sql);
                            },
                        };
                    },
                    getLimitSqlSyntax: this.sql.getLimitSqlSyntax,
                    entityIsUsedForTheFirstTime: (y) => x.entityIsUsedForTheFirstTime(y),
                    transaction: (z) => x.transaction(z),
                    supportsJsonColumnType: this.sql.supportsJsonColumnType,
                    wrapIdentifier: this.wrapIdentifier,
                }));
            }
            finally {
                completed = true;
            }
        });
    }
    static rawFilter(build) {
        return {
            [customDatabaseFilterToken]: {
                buildSql: build,
            },
        };
    }
    static async filterToRaw(repo, condition, sqlCommand, dbNames) {
        if (!sqlCommand) {
            sqlCommand = new myDummySQLCommand();
        }
        const r = getRepository(repo);
        var b = new FilterConsumerBridgeToSqlRequest(sqlCommand, dbNames || (await dbNamesOf(r.metadata)));
        b._addWhere = false;
        await (await getRepositoryInternals(r).translateWhereToFilter(condition)).__applyToConsumer(b);
        return await b.resolveWhere();
    }
    /**
     * `false` _(default)_ - No logging
     *
     * `true` - to log all queries to the console
     *
     * `oneLiner` - to log all queries to the console as one line
     *
     * a `function` - to log all queries to the console as a custom format
     */
    static LogToConsole = false;
    /**
     * Threshold in milliseconds for logging queries to the console.
     */
    static durationThreshold = 0;
    constructor(sql) {
        this.sql = sql;
        if (sql.wrapIdentifier)
            this.wrapIdentifier = (x) => sql.wrapIdentifier(x);
    }
    createdEntities = [];
}
const icons = new Map([
    // CRUD
    ['INSERT', 'âšª'],
    ['SELECT', 'ðŸ”µ'],
    ['UPDATE', 'ðŸŸ£'],
    ['DELETE', 'ðŸŸ¤'],
    // Additional
    ['CREATE', 'ðŸŸ©'],
    ['ALTER', 'ðŸŸ¨'],
    ['DROP', 'ðŸŸ¥'],
    ['TRUNCATE', 'â¬›'],
    ['GRANT', 'ðŸŸª'],
    ['REVOKE', 'ðŸŸ«'], // Used to take back permissions from a user.
]);
class LogSQLCommand {
    origin;
    logToConsole;
    constructor(origin, logToConsole) {
        this.origin = origin;
        this.logToConsole = logToConsole;
    }
    args = {};
    addParameterAndReturnSqlToken(val) {
        let r = this.origin.addParameterAndReturnSqlToken(val);
        this.args[r] = val;
        return r;
    }
    async execute(sql) {
        try {
            let start = new Date();
            let r = await this.origin.execute(sql);
            if (this.logToConsole !== false) {
                var d = new Date().valueOf() - start.valueOf();
                if (d > SqlDatabase.durationThreshold) {
                    const duration = d / 1000;
                    if (this.logToConsole === 'oneLiner') {
                        const rawSql = sql
                            .replace(/(\r\n|\n|\r|\t)/gm, ' ')
                            .replace(/  +/g, ' ')
                            .trim();
                        const first = rawSql.split(' ')[0].toUpperCase();
                        console.info(`${icons.get(first) || 'ðŸ’¢'} (${duration.toFixed(3)}) ${rawSql} ${JSON.stringify(this.args)}`);
                    }
                    else if (typeof this.logToConsole === 'function') {
                        this.logToConsole(duration, sql, this.args);
                    }
                    else {
                        console.info(sql + '\n', { arguments: this.args, duration });
                    }
                }
            }
            return r;
        }
        catch (err) {
            console.error((err.message || 'Sql Error') + ':\n', sql, {
                arguments: this.args,
                error: err,
            });
            throw err;
        }
    }
}
class ActualSQLServerDataProvider {
    entity;
    sql;
    iAmUsed;
    strategy;
    static LogToConsole = false;
    constructor(entity, sql, iAmUsed, strategy) {
        this.entity = entity;
        this.sql = sql;
        this.iAmUsed = iAmUsed;
        this.strategy = strategy;
    }
    async init() {
        let dbNameProvider = await dbNamesOf(this.entity, (x) => this.sql.wrapIdentifier(x));
        await this.iAmUsed(dbNameProvider);
        return dbNameProvider;
    }
    async count(where) {
        let e = await this.init();
        let select = 'select count(*) count from ' + e.$entityName;
        let r = this.sql.createCommand();
        if (where) {
            let wc = new FilterConsumerBridgeToSqlRequest(r, e);
            where.__applyToConsumer(wc);
            select += await wc.resolveWhere();
        }
        return r.execute(select).then((r) => {
            return Number(r.rows[0].count);
        });
    }
    async find(options) {
        let e = await this.init();
        let { colKeys, select } = this.buildSelect(e);
        select = 'select ' + select;
        select += '\n from ' + e.$entityName;
        let r = this.sql.createCommand();
        if (options) {
            if (options.where) {
                let where = new FilterConsumerBridgeToSqlRequest(r, e);
                options.where.__applyToConsumer(where);
                select += await where.resolveWhere();
            }
            if (options.limit) {
                options.orderBy = Sort.createUniqueSort(this.entity, options.orderBy);
            }
            if (!options.orderBy) {
                options.orderBy = Sort.createUniqueSort(this.entity, new Sort());
            }
            if (options.orderBy) {
                let first = true;
                let segs = [];
                for (const s of options.orderBy.Segments) {
                    if (s.field instanceof CompoundIdField) {
                        segs.push(...s.field.fields.map((c) => ({
                            field: c,
                            isDescending: s.isDescending,
                        })));
                    }
                    else
                        segs.push(s);
                }
                for (const c of segs) {
                    if (first) {
                        select += ' Order By ';
                        first = false;
                    }
                    else
                        select += ', ';
                    select += e.$dbNameOf(c.field);
                    if (c.isDescending)
                        select += ' desc';
                }
            }
            if (options.limit) {
                let page = 1;
                if (options.page)
                    page = options.page;
                if (page < 1)
                    page = 1;
                select +=
                    ' ' +
                        this.strategy.getLimitSqlSyntax(options.limit, (page - 1) * options.limit);
            }
        }
        return r.execute(select).then((r) => {
            return r.rows.map((y) => {
                return this.buildResultRow(colKeys, y, r);
            });
        });
    }
    buildResultRow(colKeys, y, r) {
        let result = {};
        for (let index = 0; index < colKeys.length; index++) {
            const col = colKeys[index];
            try {
                result[col.key] = col.valueConverter.fromDb(y[r.getColumnKeyInResultForIndexInSelect(index)]);
            }
            catch (err) {
                throw new Error('Failed to load from db:' + col.key + '\r\n' + err);
            }
        }
        return result;
    }
    buildSelect(e) {
        let select = '';
        let colKeys = [];
        for (const x of this.entity.fields) {
            if (x.isServerExpression) {
            }
            else {
                if (colKeys.length > 0)
                    select += ', ';
                select += e.$dbNameOf(x);
                colKeys.push(x);
            }
        }
        return { colKeys, select };
    }
    async update(id, data) {
        let e = await this.init();
        let r = this.sql.createCommand();
        let f = new FilterConsumerBridgeToSqlRequest(r, e);
        Filter.fromEntityFilter(this.entity, this.entity.idMetadata.getIdFilter(id)).__applyToConsumer(f);
        let statement = 'update ' + e.$entityName + ' set ';
        let added = false;
        for (const x of this.entity.fields) {
            if (x instanceof CompoundIdField) {
            }
            if (isDbReadonly(x, e)) {
            }
            else if (data[x.key] !== undefined) {
                let v = x.valueConverter.toDb(data[x.key]);
                if (v !== undefined) {
                    if (!added)
                        added = true;
                    else
                        statement += ', ';
                    statement +=
                        e.$dbNameOf(x) + ' = ' + r.addParameterAndReturnSqlToken(v);
                }
            }
        }
        statement += await f.resolveWhere();
        let { colKeys, select } = this.buildSelect(e);
        statement += ' returning ' + select;
        return r.execute(statement).then((sqlResult) => {
            this.sql._getSourceSql().afterMutation?.();
            return this.buildResultRow(colKeys, sqlResult.rows[0], sqlResult);
        });
    }
    async delete(id) {
        let e = await this.init();
        let r = this.sql.createCommand();
        let f = new FilterConsumerBridgeToSqlRequest(r, e);
        Filter.fromEntityFilter(this.entity, this.entity.idMetadata.getIdFilter(id)).__applyToConsumer(f);
        let statement = 'delete from ' + e.$entityName;
        statement += await f.resolveWhere();
        return r.execute(statement).then(() => {
            this.sql._getSourceSql().afterMutation?.();
        });
    }
    async insert(data) {
        let e = await this.init();
        let r = this.sql.createCommand();
        let cols = '';
        let vals = '';
        let added = false;
        for (const x of this.entity.fields) {
            if (isDbReadonly(x, e)) {
            }
            else {
                let v = x.valueConverter.toDb(data[x.key]);
                if (v != undefined) {
                    if (!added)
                        added = true;
                    else {
                        cols += ', ';
                        vals += ', ';
                    }
                    cols += e.$dbNameOf(x);
                    vals += r.addParameterAndReturnSqlToken(v);
                }
            }
        }
        let statement = `insert into ${e.$entityName} (${cols}) values (${vals})`;
        let { colKeys, select } = this.buildSelect(e);
        statement += ' returning ' + select;
        return await r.execute(statement).then((sql) => {
            this.sql._getSourceSql().afterMutation?.();
            return this.buildResultRow(colKeys, sql.rows[0], sql);
        });
    }
}
class myDummySQLCommand {
    execute(sql) {
        throw new Error('Method not implemented.');
    }
    addParameterAndReturnSqlToken(val) {
        if (val === null)
            return 'null';
        if (val instanceof Date)
            val = val.toISOString();
        if (typeof val == 'string') {
            if (val == undefined)
                val = '';
            return "'" + val.replace(/'/g, "''") + "'";
        }
        return val.toString();
    }
}
async function bulkInsert(array, db) {
    if (array.length == 0)
        return;
    const chunkSize = 250;
    for (let i = 0; i < array.length; i += chunkSize) {
        const items = array.slice(i, i + chunkSize);
        // do whatever
        const c = db.createCommand();
        let sql = 'insert into ' +
            (await items[0]._.metadata.dbName) +
            ' (' +
            (await Promise.all(items[0]._.metadata.fields.toArray().map((f) => f.dbName))).join(',') +
            ') values ';
        sql += items
            .map((row) => '(' +
            row.$.toArray()
                .map((f) => c.addParameterAndReturnSqlToken(f.metadata.valueConverter.toDb(f.value)))
                .join(', ') +
            ')')
            .join(',');
        await c.execute(sql);
    }
}
