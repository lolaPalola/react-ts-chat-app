import { createId } from '@paralleldrive/cuid2';
import { v4 as uuid } from 'uuid';
import { ValueConverters } from '../valueConverters.js';
import { buildOptions } from './RepositoryImplementation.js';
import { Validators } from '../validators.js';
import { relationInfoMemberInOptions } from './relationInfoMember.js';
import { remultStatic } from '../remult-static.js';
export class Fields {
    /**
     * Stored as a JSON.stringify - to store as json use Fields.json
     */
    static object(...options) {
        return Field(undefined, ...options);
    }
    static json(...options) {
        let op = options;
        if (op.valueConverter && !op.valueConverter.fieldTypeInDb)
            //@ts-ignore
            op.valueConverter.fieldTypeInDb = 'json';
        return Field(undefined, {
            valueConverter: {
                fieldTypeInDb: 'json',
            },
        }, ...options);
    }
    static dateOnly(...options) {
        return Field(() => Date, {
            valueConverter: ValueConverters.DateOnly,
        }, ...options);
    }
    static date(...options) {
        return Field(() => Date, ...options);
    }
    static integer(...options) {
        return Field(() => Number, {
            valueConverter: ValueConverters.Integer,
        }, ...options);
    }
    static autoIncrement(...options) {
        return Field(() => Number, {
            allowApiUpdate: false,
            dbReadOnly: true,
            valueConverter: {
                ...ValueConverters.Integer,
                fieldTypeInDb: 'autoincrement',
            },
        }, ...options);
    }
    static number(...options) {
        return Field(() => Number, ...options);
    }
    static createdAt(...options) {
        return Field(() => Date, {
            allowApiUpdate: false,
            saving: (_, ref, { isNew }) => {
                if (isNew)
                    ref.value = new Date();
            },
        }, ...options);
    }
    static updatedAt(...options) {
        return Field(() => Date, {
            allowApiUpdate: false,
            saving: (_, ref) => {
                ref.value = new Date();
            },
        }, ...options);
    }
    static uuid(...options) {
        return Field(() => String, {
            allowApiUpdate: false,
            defaultValue: () => uuid(),
            saving: (_, r) => {
                if (!r.value)
                    r.value = uuid();
            },
        }, ...options);
    }
    static cuid(...options) {
        return Field(() => String, {
            allowApiUpdate: false,
            defaultValue: () => createId(),
            saving: (_, r) => {
                if (!r.value)
                    r.value = createId();
            },
        }, ...options);
    }
    static string(...options) {
        return Field(() => String, ...options);
    }
    static boolean(...options) {
        return Field(() => Boolean, ...options);
    }
}
export class Relations {
    /**
     * Define a to-one relation between entities, indicating a one-to-one relationship.
     * If no field or fields are provided, it will automatically create a field in the database
     * to represent the relation.
     *
     * @param toEntityType A function that returns the target entity type.
     * @param options (Optional): An object containing options for configuring the to-one relation.
     * @returns A decorator function to apply the to-one relation to an entity field.
     *
     * Example usage:
     * ```
     * @Relations.toOne(() => Customer)
     * customer?: Customer;
     * ```
     * ```
     * Fields.string()
     * customerId?: string;
     *
     * @Relations.toOne(() => Customer, "customerId")
     * customer?: Customer;
     * ```
     * ```
     * Fields.string()
     * customerId?: string;
     *
     * @Relations.toOne(() => Customer, {
     *   field: "customerId",
     *   defaultIncluded: true
     * })
     * customer?: Customer;
     * ```
     * ```
     * Fields.string()
     * customerId?: string;
     *
     * @Relations.toOne(() => Customer, {
     *   fields: {
     *     customerId: "id",
     *   },
     * })
     * customer?: Customer;
     * ```
     */
    static toOne(toEntityType, options) {
        let op = (typeof options === 'string'
            ? { field: options }
            : !options
                ? {}
                : options);
        if (!op.field && !op.fields && !op.findOptions)
            //@ts-ignore
            return Field(toEntityType, {
                ...op,
                ...relationInfoMemberInOptions(toEntityType, 'reference'),
            });
        return Field(() => undefined, {
            ...op,
            serverExpression: () => undefined,
            ...relationInfoMemberInOptions(toEntityType, 'toOne'),
        });
    }
    static toMany(toEntityType, options) {
        let op = (typeof options === 'string'
            ? { field: options }
            : options);
        return Field(() => undefined, {
            ...op,
            serverExpression: () => undefined,
            ...relationInfoMemberInOptions(toEntityType, 'toMany'),
        });
    }
}
/**Decorates fields that should be used as fields.
 * for more info see: [Field Types](https://remult.dev/docs/field-types.html)
 *
 * FieldOptions can be set in two ways:
 * @example
 * // as an object
 * @Fields.string({ includeInApi:false })
 * title='';
 * @example
 * // as an arrow function that receives `remult` as a parameter
 * @Fields.string((options,remult) => options.includeInApi = true)
 * title='';
 */
export function Field(valueType, ...options) {
    // import ANT!!!! if you call this in another decorator, make sure to set It's return type correctly with the | undefined
    return (target, context, c) => {
        const key = typeof context === 'string' ? context : context.name.toString();
        let factory = (remult) => {
            let r = buildOptions(options, remult);
            if (r.required) {
                r.validate = addValidator(r.validate, Validators.required);
            }
            if (r.maxLength) {
                r.validate = addValidator(r.validate, Validators.maxLength(r.maxLength));
            }
            if (r.minLength) {
                r.validate = addValidator(r.validate, Validators.minLength(r.minLength));
            }
            if (!r.valueType && valueType) {
                r.valueType = valueType();
            }
            if (!r.key) {
                r.key = key;
            }
            if (!r.dbName)
                r.dbName = r.key;
            let type = r.valueType;
            if (!type) {
                type =
                    typeof Reflect.getMetadata == 'function'
                        ? Reflect.getMetadata('design:type', target, key)
                        : [];
                r.valueType = type;
            }
            if (!r.target)
                r.target = target;
            return r;
        };
        checkTarget(target);
        let names = remultStatic.columnsOfType.get(target.constructor);
        if (!names) {
            names = [];
            remultStatic.columnsOfType.set(target.constructor, names);
        }
        let set = names.find((x) => x.key == key);
        if (!set)
            names.push({
                key,
                settings: factory,
            });
        else {
            let prev = set.settings;
            set.settings = (c) => {
                let prevO = prev(c);
                let curr = factory(c);
                return Object.assign(prevO, curr);
            };
        }
    };
}
export function checkTarget(target) {
    if (!target)
        throw new Error("Set the 'experimentalDecorators:true' option in your 'tsconfig' or 'jsconfig' (target undefined)");
}
function addValidator(validators, newValidator, atStart = false) {
    if (!newValidator)
        return;
    const newValidators = Array.isArray(newValidator)
        ? newValidator
        : [newValidator];
    const validatorsArray = Array.isArray(validators)
        ? validators
        : validators
            ? [validators]
            : [];
    return atStart
        ? [...newValidators, ...validatorsArray]
        : [...validatorsArray, ...newValidators];
}
